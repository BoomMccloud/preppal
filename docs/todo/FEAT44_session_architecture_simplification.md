# FEAT44: Session Architecture Simplification

> **Status:** Ready
> **Created:** 2025-12-31
> **Related:** FEAT40 (Block Isolation), FEAT42 (Close Code Handling)

## Problem Statement

The interview session architecture has accumulated complexity that makes it fragile and hard to maintain. A recent change to unify `CONNECTION_READY` into `CONNECTION_ESTABLISHED` exposed a hidden race condition caused by the driver's internal state guards.

## Root Cause Analysis

### The Bug That Revealed the Complexity

When `CONNECTION_ESTABLISHED` generated a `START_CONNECTION` command:

1. `reconnectForBlock()` reset `hasInitiatedConnection = false` and called `generateToken()`
2. Token succeeded, WebSocket connected
3. `CONNECTION_ESTABLISHED` fired → generated `START_CONNECTION` command
4. `START_CONNECTION` called `driver.connect()`
5. Since flag was `false`, `connect()` called `generateToken()` **again**
6. Second `generateToken()` failed → `CONNECTION_ERROR` → interview ended

### Why It Was Hidden

Before the change, `CONNECTION_READY` was only dispatched via `SessionContentDev`'s `onConnectionReady` callback. That callback had a `connectionReadyCalledRef` guard that was **never reset**, so it only fired on the initial connection, not on block transitions.

This hidden coupling between UI state (`connectionReadyCalledRef`) and driver state (`hasInitiatedConnection`) masked the architectural flaw.

## First-Principle Analysis

### Current Architecture Violations

| Principle | Violation | Risk |
|-----------|-----------|------|
| **Source of Truth** | Driver has hidden state (`hasInitiatedConnection`, `currentBlockRef`) | Split-brain between reducer and driver |
| **Dumb Driver** | Driver decides when to connect via guards | Business logic in infrastructure |
| **Command Clarity** | `START_CONNECTION` is now a no-op | Dead code, confusion |
| **Single Responsibility** | `RECONNECT_FOR_BLOCK` and `connect()` do similar things | Duplicate paths |

### State Topology Problem

```
Reducer State (visible):        Driver State (hidden):
├─ connectionState: "live"      ├─ hasInitiatedConnection: true/false  ← DANGEROUS
├─ status: "ANSWERING"          ├─ currentBlockRef: number
├─ blockIndex: 0                ├─ wsRef: WebSocket
└─ targetBlockIndex: 1          └─ activeConnectionsRef: number
```

The driver's `hasInitiatedConnection` flag is a **guard** that decides whether to actually connect. This violates the "Dumb Driver" principle - drivers should execute commands, not decide whether to execute them.

## Simplification Options

### Option A: Minimal Cleanup (Phase 1 - Recommended)

Remove dead code without changing behavior:

| Change | Risk | Impact |
|--------|------|--------|
| Remove `START_CONNECTION` from types | None | Clean types |
| Remove from command executor | None | Less code |
| Update tests | None | Accurate tests |

**Lines removed:** ~30
**Behavior change:** None

### Option B: Dumber Driver (Phase 2 - Future)

Make the driver truly stateless:

```typescript
// BEFORE: Smart driver with guards
connect() {
  if (!hasInitiatedConnection.current) {  // <-- Decision
    hasInitiatedConnection.current = true;
    generateToken(...);
  }
}

reconnectForBlock(block) {
  currentBlockRef.current = block;           // <-- Owns state
  hasInitiatedConnection.current = false;    // <-- Manages lifecycle
  generateToken();
}

// AFTER: Dumb driver, reducer owns all state
connectForBlock(block: number) {
  // Always connects, no guards
  // Reducer is responsible for not calling this twice
  generateToken({ interviewId, block });
}
```

**Commands simplified:**
```typescript
// BEFORE
| START_CONNECTION    | → driver.connect() (with guard)
| RECONNECT_FOR_BLOCK | → driver.reconnectForBlock()

// AFTER
| CONNECT_FOR_BLOCK   | → driver.connectForBlock(block)
```

### Option C: Remove Auto-Connect (Phase 3 - Future)

Currently the initial connection is implicit:
```typescript
// useInterviewSession.ts
useEffect(() => {
  driver.connect();  // Auto-connect on mount
}, []);
```

This could become explicit:
```typescript
// Reducer generates CONNECT command from initial state
const initialState = {
  status: "WAITING_FOR_CONNECTION",
  // Initial command generated by reducer, not useEffect
};

// On first TICK or explicit START event:
case "START_INTERVIEW":
  return {
    state,
    commands: [{ type: "CONNECT_FOR_BLOCK", blockNumber: 1 }]
  };
```

## Solution: Phase 1 (Option A)

### 1. Remove START_CONNECTION from types

**File:** `src/app/[locale]/(interview)/interview/[interviewId]/session/types.ts`

```typescript
// REMOVE this line from Command union:
| { type: "START_CONNECTION"; blockNumber: number }
```

### 2. Remove from command executor

**File:** `src/app/[locale]/(interview)/interview/[interviewId]/session/hooks/useInterviewSession.ts`

```typescript
// REMOVE this case:
case "START_CONNECTION":
  driver.connect();
  break;
```

### 3. Update README

**File:** `src/app/[locale]/(interview)/interview/[interviewId]/session/README.md`

Remove references to `START_CONNECTION` in the command documentation.

## Files to Modify

| File | Change |
|------|--------|
| `types.ts` | Remove `START_CONNECTION` from Command union |
| `hooks/useInterviewSession.ts` | Remove `START_CONNECTION` case from executor |
| `README.md` | Update command documentation |

## Unit Tests

No new tests needed - existing tests already don't expect `START_CONNECTION` commands (we removed those expectations in the previous fix).

Verify:
```bash
pnpm test -- --grep "session-reducer"
pnpm test -- --grep "session-golden-path"
```

## Acceptance Criteria (Phase 1)

- [ ] `START_CONNECTION` removed from types
- [ ] `START_CONNECTION` case removed from command executor
- [ ] All existing tests pass
- [ ] `pnpm check` passes
- [ ] Manual test: Complete a 2+ block interview successfully

## Future Phases

### Phase 2: Dumber Driver

**Goal:** Remove driver's internal state guards

**Changes:**
1. Remove `hasInitiatedConnection` from driver
2. Merge `connect()` and `reconnectForBlock()` into `connectForBlock(block)`
3. Reducer becomes solely responsible for not double-connecting

**Risk:** Medium - requires careful state machine review

### Phase 3: Explicit Initial Connection

**Goal:** Remove implicit auto-connect useEffect

**Changes:**
1. Initial connection becomes a command from reducer
2. No side effects on mount
3. Complete control flow visibility in reducer

**Risk:** Medium - changes initialization sequence

## Appendix: First-Principle Checklist

| Principle | Current State | After Phase 1 | After Phase 2+ |
|-----------|--------------|---------------|----------------|
| **Source of Truth** | Split (reducer + driver) | Split (unchanged) | Unified (reducer only) |
| **Dumb Driver** | Smart (has guards) | Smart (unchanged) | Dumb (executes only) |
| **Command Clarity** | Dead code exists | Clean | Clean |
| **Testability** | Good (reducer is pure) | Good | Better (no hidden state) |

## Appendix: Architecture Comparison

### Current Flow (Complex)

```
Mount
  │
  ▼
useEffect calls driver.connect()
  │
  ▼
driver checks hasInitiatedConnection ─── true ──► (no-op)
  │
  │ false
  ▼
driver sets flag, calls generateToken()
  │
  ▼
Token succeeds → connectWebSocket()
  │
  ▼
WebSocket opens → CONNECTION_ESTABLISHED
  │
  ▼
Reducer transitions to ANSWERING
```

### Block Transition (Where Bug Occurred)

```
User clicks Continue
  │
  ▼
Reducer: WAITING_FOR_CONNECTION + RECONNECT_FOR_BLOCK command
  │
  ▼
Executor calls driver.reconnectForBlock(block)
  │
  ▼
Driver resets hasInitiatedConnection = false  ← DANGER
  │
  ▼
Driver calls generateToken()
  │
  ▼
Token succeeds → WebSocket opens
  │
  ▼
CONNECTION_ESTABLISHED → Reducer transitions to ANSWERING
  │
  ▼
(Previously: START_CONNECTION command → driver.connect())
  │
  ▼
(Previously: Flag is false → SECOND generateToken() → FAILURE)
```

### Target Flow (Phase 2+)

```
Mount
  │
  ▼
useEffect dispatches START_INTERVIEW event (or TICK triggers it)
  │
  ▼
Reducer: CONNECT_FOR_BLOCK command
  │
  ▼
Executor calls driver.connectForBlock(1)
  │
  ▼
Driver ALWAYS connects (no guards)
  │
  ▼
WebSocket opens → CONNECTION_ESTABLISHED
  │
  ▼
Reducer transitions to ANSWERING (no commands)

Block Transition:
  │
  ▼
User clicks Continue
  │
  ▼
Reducer: WAITING_FOR_CONNECTION + CONNECT_FOR_BLOCK(nextBlock)
  │
  ▼
Executor calls driver.connectForBlock(nextBlock)
  │
  ▼
Driver ALWAYS connects (no guards, no flag management)
  │
  ▼
WebSocket opens → CONNECTION_ESTABLISHED
  │
  ▼
Reducer transitions to ANSWERING (no commands)
```

**Key difference:** No hidden state in driver. Reducer is sole decision-maker.
